<!DOCTYPE html>
<html> 
  <head>
    <title>Processing.JS inside Webpages: Template</title> 
  </head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(400, 400); 
      frameRate(60);
        
      // Paste code from Khan Academy here:

// Bike 

background(235, 235, 235);
rectMode(CENTER);

angleMode = "radians";

var timeAngle = 0;
var time = 0;
var bikeSpeed = 2;
var timeTerrain = 0;
var roadPerlin = 0;
var roadSlope = 0;
var xX = -220;   //  rotation point
var yY = -327;   //  rotation point

var bike = function()  {

fill(235, 235, 235, 0);
strokeWeight(3);

beginShape();      // Frame
vertex(220+xX, 280+yY);  // 1
vertex(150+xX, 210+yY);  // 2
vertex(153+xX, 200+yY);  // 3
vertex(260+xX, 200+yY);  // 4
vertex(220+xX, 280+yY);  // 5
vertex(300+xX, 280+yY);  // 6
vertex(260+xX, 200+yY);  // 7
endShape(CLOSE);

line(260+xX, 200+yY, 265+xX, 190+yY);     // Seat post
ellipse(130+xX, 280+yY, 100, 100);  // front tire
ellipse(300+xX, 280+yY, 100, 100);  // back tire

line(130+xX, 280+yY, 161+xX, 170+yY);     // Fork
line(140+xX, 170+yY, 161+xX, 170+yY);
line(120+xX, 178+yY, 165+xX, 161+yY);     // Handle bar
rect(268+xX, 182+yY, 30, 10, 10);   // Seat
ellipse(220+xX, 280+yY, 25, 25);    // Crank disk
ellipse(300+xX, 280+yY, 10, 10);    // Gear
strokeWeight(1);
line(220+xX, 268+yY, 300+xX, 274+yY);     // Chain
line(220+xX, 294+yY, 300+xX, 286+yY);

strokeWeight(3);
fill(255, 0, 0);
quad(200+xX, 105+yY, 280+xX, 180+yY, 250+xX, 180+yY, 200+xX, 120+yY); // torso
ellipse(180+xX, 110+yY, 40, 30);  // head
fill(255);
ellipse(175+xX, 115+yY, 2, 2);                      // eye
triangle(175+xX, 127+yY, 180+xX, 127+yY,180+xX, 135+yY);        // nose

strokeWeight(5);
line(195+xX, 157+yY, 165+xX, 161+yY);                     // right arm
line(195+xX, 157+yY, 205+xX, 128+yY); 
line(205+xX, 177+yY, 210+xX, 125+yY);                     // left arm
line(205+xX, 177+yY, 165+xX, 135+yY);

};

// Main program

var timeTerrain = 0;
var roadPerlin = 0;
var blockHight = [];
var once1 = true;
var gg = 0;
var bikeAngle = 0;

draw = function()  {
  
    background(255, 0, 111,0);
    strokeWeight(1);
//    noStroke();
    
    var timeTerrainRnd = round(timeTerrain);
    
    for(var i=-2; i < 22; i += 1){
  
        fill(13, 255, 0);
        
       // quadrilateral base or ground
  
       quad(  i * 20 + timeTerrainRnd +20, 270 + 100 * blockHight[i+3],  i * 20 + timeTerrainRnd +20,  230 + 100 * blockHight[i+2] + 200,  i * 20 + timeTerrainRnd ,  230 + 100 * blockHight[i+2] + 200,                   i * 20 + timeTerrainRnd ,         270 + 100 * blockHight[i+2]);   
    } 
    
 // Bike 
 
 // Translate and rotate                                            

    pushMatrix();
        //translate(0,  (blockHight[0] + blockHight[10])*50 - 60) ; //  
    translate(-xX, -yY - 60 + (blockHight[7] + blockHight[16])*50 );

    bikeAngle = - atan((blockHight[7] - blockHight[16])*100 / 200);
    rotate(bikeAngle);

    strokeWeight(3);
 
    bike();
 
    strokeWeight(1);                              // spokes
    timeAngle = time * 16 * bikeSpeed ;   

    for(var i = 0; i < 16 ; i += 1) {               // Front wheel spokes
    
        var    wheelAngle = i * PI/8 + timeAngle;
        var    spokeX = 130 + 50 * sin(wheelAngle);
        var    spokeY = 280 + 50 * cos(wheelAngle);
    
        line(130+xX, 280+yY, spokeX+xX, spokeY+yY);             // front spokes
    }

    for(var i = 0; i < 16 ; i += 1) {               // Back wheel spokes
    
        var    wheelAngle = i * PI/8 + timeAngle;
        var    spokeX = 300+xX + 50 * sin(wheelAngle);
        var    spokeY = 280+yY + 50 * cos(wheelAngle);
    
        line(300+xX, 280+yY, spokeX, spokeY);             // back spokes
    }

    // cranks - point 5 = 220, 280
    var crankAngle = time * 700 * bikeSpeed * 2 * PI / 360; //  Pedaling speed  700

    var    crankLX = 220+xX + 20 * sin(crankAngle);
    var    crankLY = 280+yY + 20 * cos(crankAngle);

    strokeWeight(3);
    line(crankLX, crankLY, 220+xX, 280+yY);              // left side crank
    rect(crankLX, crankLY, 10, 6, 5);              // left pedal 

    var    crankRX = 220+xX + 20 * sin(crankAngle + PI);                                 //  WORKING radians or degree     
    var    crankRY = 280+yY + 20 * cos(crankAngle + PI);                                 //  WORKING radians or degree

    line(crankRX, crankRY, 220+xX, 280+yY);              // right side crank
    rect(crankRX, crankRY, 10, 6, 5);              // pedal 2      

// leg position 

strokeWeight(8);

var thigh = 66;                               // lenght of thigh and also lower leg.
var buttL = new PVector(250+xX, 175+yY);            // Hip joint
var footL = new PVector(crankLX, crankLY);    // left foot position (pedal)
var pointDL = new PVector();
pointDL = PVector.add(buttL, footL);
pointDL.div(2);                               // mid point between seat and pedal

var a = (PVector.sub(buttL, pointDL)).mag(); // distance between mid point and seat

var b = sqrt( thigh * thigh - a * a);

var alpha = atan((250+xX-pointDL.x) / (pointDL.y-175+yY));

var b_x = b * cos(alpha);
var b_y = b * sin(alpha);
                                                 // left knee vector
var kneeL = new PVector(pointDL.x - b * cos(alpha), pointDL.y - b * sin(alpha));
//line(250, 175, pointDL.x - b_x,pointDL.y - b_y); // left leg thigh
line(250+xX, 175+yY, kneeL.x , kneeL.y);                  // left leg thigh
//line(crankLX, crankLY, pointDL.x - b_x,pointDL.y - b_y);  //  left leg lower leg
line(crankLX, crankLY, kneeL.x , kneeL.y);          //  left leg lower leg

                  // now, the right side.
                  
//var thigh = 66;                               // lenght of thigh and also lower leg.
var buttR = new PVector(250+xX, 175+yY);            // Hip joint
var footR = new PVector(crankRX, crankRY);    // right foot position (pedal)
var pointDR = new PVector();
pointDR = PVector.add(buttR, footR);
pointDR.div(2);                               // mid point between seat and pedal

var aR = (PVector.sub(buttR, pointDR)).mag(); // distance between mid point and seat

var bR = sqrt( thigh * thigh - aR * aR);

var alphaR = atan((250+xX-pointDR.x) / (pointDR.y-175+yY));

//var bR_x = bR * cos(alphaR);
//var bR_y = bR * sin(alphaR);
                                                 // right knee vector
var kneeR = new PVector(pointDR.x - bR * cos(alpha), pointDR.y - bR * sin(alphaR));
//line(250, 175, pointDR.x - bR_x,pointDR.y - bR_y); // right leg thigh
line(250+xX, 175+yY, kneeR.x , kneeR.y);                  // right leg thigh
//line(crankRX, crankRY, pointDR.x - bR_x,pointDR.y - bR_y);  //  right leg lower leg
line(crankRX, crankRY, kneeR.x , kneeR.y);          //  right leg lower leg

popMatrix();

            //  after bike code. Array stuff   --    put this at the end of code.
  
  // load road noise array
  
    if(once1 && blockHight.length < 28){               // Set noise array. 
        for(var i = 0; i < 28 ; i += 1) {              // Do only once
            blockHight[i] = noise(i/100);               // Array and screen are shifted                                                         // by 3 elements.
        }                                              // Array starts at 0, to unshift.
        once1 = false; 
    }
    
//    text(blockHight.length,50,50);

    var timeTerrainRnd = round(timeTerrain);
    if(timeTerrain > 19) {                              //Put a new value in [0]
        timeTerrain = 0;
 
        if(blockHight.length < 30){                     // Stops if something is wrong
            blockHight.unshift(noise(gg/20));       // /10 ?? Changes shape of noise
                 blockHight.pop();
                 gg += 1;      // It moves for next noise
                 fill(255, 0, 0);
                
        }
    }
   
    timeTerrain += 6 ;   // speed on terrain 6

time += 0.003 ;  // speed on bike  0.003

};


  // Stop pasting here the code from the Khan place.


    }};

  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>


