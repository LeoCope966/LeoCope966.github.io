<!DOCTYPE html>
<html> 
  <head>
    <title>Processing.JS inside Webpages: Template</title> 
  </head>
  <body>
	<!--This draws the canvas on the webpage -->
    <canvas id="mycanvas"></canvas> 
  </body>
 
  <!-- Include the processing.js library -->
  <!-- See https://khanacademy.zendesk.com/hc/en-us/articles/202260404-What-parts-of-ProcessingJS-does-Khan-Academy-support- for differences -->
  <script src="https://cdn.jsdelivr.net/processing.js/1.4.8/processing.min.js"></script> 
  <script>
  var programCode = function(processingInstance) {
    with (processingInstance) {
      size(400, 400); 
      frameRate(60);
        
      // Paste code from Khan Academy here:

// Bike on Khan Academy javascript.

background(235, 235, 235);
rectMode(CENTER);
angleMode = "degrees";

var timeAngle = 0;
var time = 0;
var bikeSpeed = 2;
var timeTerrain = 0;
var roadPerlin = 0;
var roadSlope = 0;

var bike = function()  {

fill(235, 235, 235, 0);
strokeWeight(3);

beginShape();      // Frame
vertex(220, 280);  // 1
vertex(150, 210);  // 2
vertex(153, 200);  // 3
vertex(260, 200);  // 4
vertex(220, 280);  // 5
vertex(300, 280);  // 6
vertex(260, 200);  // 7
endShape(CLOSE);

line(260, 200, 265, 190);     // Seat post
ellipse(130, 280, 100, 100);  // front tire
ellipse(300, 280, 100, 100);  // back tire

line(130, 280, 161, 170);     // Fork
line(140, 170, 161, 170);
line(120, 178, 165, 161);     // Handle bar
rect(268, 182, 30, 10, 10);   // Seat
ellipse(220, 280, 25, 25);    // Crank disk
ellipse(300, 280, 10, 10);    // Gear
strokeWeight(1);
line(220, 268, 300, 274);     // Chain
line(220, 294, 300, 286);

strokeWeight(3);
fill(255, 0, 0);
quad(200, 105, 280, 180, 250, 180, 200, 120); // torso
ellipse(180, 110, 40, 30);  // head
fill(255);
ellipse(175, 115, 2, 2);                      // eye
triangle(175, 127, 180, 127,180, 135);        // nose

strokeWeight(5);
line(195, 157, 165, 161);                     // right arm
line(195, 157, 205, 128); 
line(205, 177, 210, 125);                     // left arm
line(205, 177, 165, 135);

};

// Main program

var timeTerrain = 0;
var roadPerlin = 0;
var blockHight = [];
var once1 = true;
var gg = 0;
var bikeAngle = 0;

draw = function()  {
  
    background(255, 0, 111,0);
    strokeWeight(1);
//    noStroke();
    
    var timeTerrainRnd = round(timeTerrain);
    
    for(var i=-2; i < 22; i += 1){
  
        fill(13, 255, 0);
        
       // quadrilateral base or ground
  
       quad(  i * 20 + timeTerrainRnd +20, 270 + 100 * blockHight[i+3],  i * 20 + timeTerrainRnd +20,  230 + 100 * blockHight[i+2] + 200,  i * 20 + timeTerrainRnd ,  230 + 100 * blockHight[i+2] + 200,                   i * 20 + timeTerrainRnd ,         270 + 100 * blockHight[i+2]);   
    } 
    
 // Bike 
 
translate(0,  (blockHight[0] + blockHight[10])*50 - 60) ; //      

 bikeAngle = - atan((blockHight[3] - blockHight[17])*100 / 200);
 rotate(bikeAngle);

strokeWeight(3);
 
     bike();
 
    strokeWeight(1);                              // spokes
    timeAngle = time * 16 * bikeSpeed ;   

    for(var i = 0; i < 16 ; i += 1) {               // Front wheel spokes
    
        var    wheelAngle = i * 22.5 + timeAngle;
        var    spokeX = 130 + 50 * sin(wheelAngle);
        var    spokeY = 280 + 50 * cos(wheelAngle);
    
        line(130, 280, spokeX, spokeY);             // front spokes
    }

    for(var i = 0; i < 16 ; i += 1) {               // Back wheel spokes
    
        var    wheelAngle = i * 22.5 + timeAngle;
        var    spokeX = 300 + 50 * sin(wheelAngle);
        var    spokeY = 280 + 50 * cos(wheelAngle);
    
        line(300, 280, spokeX, spokeY);             // back spokes
    }

    // cranks - point 5 = 220, 280
    var crankAngle = time * 8 * bikeSpeed * 2 * PI / 360;         //  Pedaling speed              WORKING radians or degree

    var    crankLX = 220 + 20 * sin(crankAngle);
    var    crankLY = 280 + 20 * cos(crankAngle);

    strokeWeight(3);
    line(crankLX, crankLY, 220, 280);              // left side crank
    rect(crankLX, crankLY, 10, 6, 5);              // left pedal 

    var    crankRX = 220 + 20 * sin(crankAngle + PI);                                 //  WORKING radians or degree     
    var    crankRY = 280 + 20 * cos(crankAngle + PI);                                 //  WORKING radians or degree

    line(crankRX, crankRY, 220, 280);              // right side crank
    rect(crankRX, crankRY, 10, 6, 5);              // pedal 2      

// leg position 

strokeWeight(8);

var thigh = 66;                               // lenght of thigh and also lower leg.
var buttL = new PVector(250, 175);            // Hip joint
var footL = new PVector(crankLX, crankLY);    // left foot position (pedal)
var pointDL = new PVector();
pointDL = PVector.add(buttL, footL);
pointDL.div(2);                               // mid point between seat and pedal

var a = (PVector.sub(buttL, pointDL)).mag(); // distance between mid point and seat

var b = sqrt( thigh * thigh - a * a);

var alpha = atan((250-pointDL.x) / (pointDL.y-175));

var b_x = b * cos(alpha);
var b_y = b * sin(alpha);
                                                 // left knee vector
var kneeL = new PVector(pointDL.x - b * cos(alpha), pointDL.y - b * sin(alpha));
//line(250, 175, pointDL.x - b_x,pointDL.y - b_y); // left leg thigh
line(250, 175, kneeL.x , kneeL.y);                  // left leg thigh
//line(crankLX, crankLY, pointDL.x - b_x,pointDL.y - b_y);  //  left leg lower leg
line(crankLX, crankLY, kneeL.x , kneeL.y);          //  left leg lower leg

                  // now, the right side.
                  
//var thigh = 66;                               // lenght of thigh and also lower leg.
var buttR = new PVector(250, 175);            // Hip joint
var footR = new PVector(crankRX, crankRY);    // right foot position (pedal)
var pointDR = new PVector();
pointDR = PVector.add(buttR, footR);
pointDR.div(2);                               // mid point between seat and pedal

var aR = (PVector.sub(buttR, pointDR)).mag(); // distance between mid point and seat

var bR = sqrt( thigh * thigh - aR * aR);

var alphaR = atan((250-pointDR.x) / (pointDR.y-175));

//var bR_x = bR * cos(alphaR);
//var bR_y = bR * sin(alphaR);
                                                 // right knee vector
var kneeR = new PVector(pointDR.x - bR * cos(alpha), pointDR.y - bR * sin(alphaR));
//line(250, 175, pointDR.x - bR_x,pointDR.y - bR_y); // right leg thigh
line(250, 175, kneeR.x , kneeR.y);                  // right leg thigh
//line(crankRX, crankRY, pointDR.x - bR_x,pointDR.y - bR_y);  //  right leg lower leg
line(crankRX, crankRY, kneeR.x , kneeR.y);          //  right leg lower leg

            //  after bike code. Array stuff   --    put this at the end of code.
  
  // load road noise array
  
    if(once1 && blockHight.length < 28){               // Set noise array. 
        for(var i = 0; i < 28 ; i += 1) {              // Do only once
            blockHight[i] = noise(i/10);               // Array and screen are shifted                                                         // by 3 elements.
        }                                              // Array starts at 0, to unshift.
        once1 = false; 
    }
    
//    text(blockHight.length,50,50);

    var timeTerrainRnd = round(timeTerrain);
    if(timeTerrain > 19) {                              //Put a new value in [0]
        timeTerrain = 0;
 
        if(blockHight.length < 30){                     // Stops if something is wrong
            blockHight.unshift(noise(gg/100));       // /10 ?? Changes shape of noise
                 blockHight.pop();
                 gg += 1;      // It moves for next noise
                 fill(255, 0, 0);
                
        }
    }
   
    timeTerrain += 8 ;   // speed on terrain 8.0

time += 0.2 ;  // speed on bike  0.2

//  println(noise(gg/10) + "   " + bikeAngle);
};

      // Stop pasting here the code from the Khan place.


    }};

  // Get the canvas that ProcessingJS will use
  var canvas = document.getElementById("mycanvas"); 
  // Pass the function to ProcessingJS constructor
  var processingInstance = new Processing(canvas, programCode); 
  </script>
</html>
